# Паттерн Adapter (адаптер, wrapper, обертка)
## Назначение паттерна Adapter
Часто в новом программном проекте не удается повторно использовать уже существующий код. Например, имеющиеся классы могут обладать нужной функциональностью, но иметь при этом несовместимые интерфейсы. В таких случаях следует использовать паттерн Adapter (адаптер).

Паттерн Adapter, представляющий собой программную обертку над существующими классами, преобразует их интерфейсы к виду, пригодному для последующего использования.

Рассмотрим простой пример, когда следует применять паттерн Adapter. Пусть мы разрабатываем систему климат-контроля, предназначенной для автоматического поддержания температуры окружающего пространства в заданных пределах. Важным компонентом такой системы является температурный датчик, с помощью которого измеряют температуру окружающей среды для последующего анализа. Для этого датчика уже имеется готовое программное обеспечение от сторонних разработчиков, представляющее собой некоторый класс с соответствующим интерфейсом. Однако использовать этот класс непосредственно не удастся, так как показания датчика снимаются в градусах Фаренгейта. Нужен адаптер, преобразующий температуру в шкалу Цельсия.
## Описание паттерна Adapter
Пусть класс, интерфейс которого нужно адаптировать к нужному виду, имеет имя Adaptee. Для решения задачи преобразования его интерфейса паттерн Adapter вводит следующую иерархию классов:

* Виртуальный базовый класс Target. Здесь объявляется пользовательский интерфейс подходящего вида. Только этот интерфейс доступен для пользователя.
* Производный класс Adapter, реализующий интерфейс Target. В этом классе также имеется указатель или ссылка на экземпляр Adaptee. Паттерн Adapter использует этот указатель для перенаправления клиентских вызовов в Adaptee. Так как интерфейсы Adaptee и Target несовместимы между собой, то эти вызовы обычно требуют преобразования.
## UML-диаграмма классов паттерна Adapter
![Image alt](https://github.com/Andrey-Zelinskiy/Money_Helper/blob/master/mockup/uml-adapter.jpg)
## Реализация паттерна Adapter
### Классическая реализация паттерна Adapter
Приведем реализацию паттерна Adapter. Для примера выше адаптируем показания температурного датчика системы климат-контроля, переведя их из градусов Фаренгейта в градусы Цельсия (предполагается, что код этого датчика недоступен для модификации).

#include <iostream>
  
// Уже существующий класс температурного датчика окружающей среды

class FahrenheitSensor

{
 
 public:
   
   // Получить показания температуры в градусах Фаренгейта
    
    float getFahrenheitTemp() {
     
     float t = 32.0;
     
     // ... какой то код
     
     return t;
   
   }

};
  
class Sensor

{    
 
 public:
   
   virtual ~Sensor() {}
   
   virtual float getTemperature() = 0;

};
  
class Adapter : public Sensor

{    
 
 public:
   
   Adapter( FahrenheitSensor* p ) : p_fsensor(p) {
   
   }
   
   ~Adapter() {
   
   delete p_fsensor;
  
  }
 
 float getTemperature() {
   
   return (p_fsensor->getFahrenheitTemp()-32.0)*5.0/9.0;
   
   }
 
 private:
   
   FahrenheitSensor* p_fsensor; 

};
  
int main()

{
  
  Sensor* p = new Adapter( new FahrenheitSensor);
  
  cout << "Celsius temperature = " << p->getTemperature() << endl;
  
  delete p;    
 
 return 0;

}
## Результаты применения паттерна Adapter
### Достоинства паттерна Adapter
* Паттерн Adapter позволяет повторно использовать уже имеющийся код, адаптируя его несовместимый интерфейс к виду, пригодному для использования.
###Недостатки паттерна Adapter
* Задача преобразования интерфейсов может оказаться непростой в случае, если клиентские вызовы и (или) передаваемые параметры не имеют функционального соответствия в адаптируемом объекте.
