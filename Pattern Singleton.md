# Паттерн Singleton (одиночка,синглет)
## Назначение паттерна Singleton
Часто в системе могут существовать сущности только в единственном экземпляре, например, система ведения системного журнала сообщений или драйвер дисплея. В таких случаях необходимо уметь создавать единственный экземпляр некоторого типа, предоставлять к нему доступ извне и запрещать создание нескольких экземпляров того же типа.

Паттерн Singleton предоставляет такие возможности.

## Описание паттерна Singleton
Архитектура паттерна Singleton основана на идее использования глобальной переменной, имеющей следующие важные свойства:

* Такая переменная доступна всегда. Время жизни глобальной переменной - от запуска программы до ее завершения.
* Предоставляет глобальный доступ, то есть, такая переменная может быть доступна из любой части программы.

Однако, использовать глобальную переменную некоторого типа непосредственно невозможно, так как существует проблема обеспечения единственности экземпляра, а именно, возможно создание нескольких переменных того же самого типа (например, стековых).

Для решения этой проблемы паттерн Singleton возлагает контроль над созданием единственного объекта на сам класс. Доступ к этому объекту осуществляется через статическую функцию-член класса, которая возвращает указатель или ссылку на него. Этот объект будет создан только при первом обращении к методу, а все последующие вызовы просто возвращают его адрес. Для обеспечения уникальности объекта, конструкторы и оператор присваивания объявляются закрытыми.

## UML-диаграмма классов паттерна Singleton
![Image alt](https://github.com/Andrey-Zelinskiy/Money_Helper/blob/master/mockup/uml-singleton.jpg)
## UML-диаграмма последовательностей паттерна Singleton
![Image alt](https://github.com/Andrey-Zelinskiy/Money_Helper/blob/master/mockup/singleton-sequence.png)
## Реализация паттерна Singleton
### Классическая реализация Singleton
Рассмотрим наиболее часто встречающуюся реализацию паттерна Singleton.

// Singleton.h

class Singleton

{
  
  private:
    
    static Singleton * p_instance;
    
    // Конструкторы и оператор присваивания недоступны клиентам
    
    Singleton() {}
   
   Singleton( const Singleton& );  
   
   Singleton& operator=( Singleton& );
 
 public:
   
   static Singleton * getInstance() {
        
        if(!p_instance)           
           
           p_instance = new Singleton();
       
       return p_instance;
    }
    
};

  
// Singleton.cpp

#include "Singleton.h"
  
Singleton* Singleton::p_instance = 0; 

Клиенты запрашивают единственный объект класса через статическую функцию-член getInstance(), которая при первом запросе динамически выделяет память под этот объект и затем возвращает указатель на этот участок памяти. Впоследcтвии клиенты должны сами позаботиться об освобождении памяти при помощи оператора delete.

## Результаты применения паттерна Singleton
### Достоинства паттерна Singleton
* Класс сам контролирует процесс создания единственного экземпляра.
* Паттерн легко адаптировать для создания нужного числа экземпляров.
* Возможность создания объектов классов, производных от Singleton.
### Недостатки паттерна Singleton
* В случае использования нескольких взаимозависимых одиночек их реализация может резко усложниться.
